开放式问题

1. 如何做jvm调优？有相关经验吗?基本思路是什么

   如果CPU使用率较高，GC频繁且GC时间长，可能就需要JVM调优了。
    基本思路就是让每一次GC都回收尽可能多的对象，
    对于CMS来说，要合理设置年轻代和年老代的大小。该如何确定它们的大小呢？这是一个迭代的过程，可以先采用JVM的默认值，然后通过压测分析GC日志。

   如果看年轻代的内存使用率处在高位，导致频繁的Minor GC，而频繁GC的效率又不高，说明对象没那么快能被回收，这时年轻代可以适当调大一点。

   如果看年老代的内存使用率处在高位，导致频繁的Full GC，这样分两种情况：如果每次Full GC后年老代的内存占用率没有下来，可以怀疑是内存泄漏；如果Full GC后年老代的内存占用率下来了，说明不是内存泄漏，要考虑调大年老代。

   对于G1收集器来说，可以适当调大Java堆，因为G1收集器采用了局部区域收集策略，单次垃圾收集的时间可控，可以管理较大的Java堆。

   知识储备：

     **jvm调优常用工具**

     -  jps:jvm进程状况工具

       使用:jps [options] [hostid] 

     - jstack：jstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。

       使用：jstack -l [pid] （查看java进程的线程快照信息）

     - jmap：jmap命令用于生产堆转存快照。打印出某个java进程（使用pid）内存内的，所有‘对象’的情况（如：产生那些对象，及其数量）

       使用：jmap -heap [pid]

     **内存调优关注的三个指标**

     - 吞吐量：重要指标之一，是指不考虑垃圾收集引起的停顿时间或内存消耗，垃圾收集器能支撑应用达到的最高性能指标。
     - 延迟：其度量标准是缩短由于垃圾啊收集引起的停顿时间或者完全消除因垃圾收集所引起的停顿，避免应用运行时发生抖动。
     - 内存占用：垃圾收集器流畅运行所需要 的内存数量。

     **JVM调优原则**
     - MinorGC回收原则： 每次minor GC 都要尽可能多的收集垃圾对象。以减少应用程序发生Full GC的频率。
     - GC内存最大化原则：处理吞吐量和延迟问题时候，垃圾处理器能使用的内存越大，垃圾收集的效果越好，应用程序也会越来越流畅。
     - GC调优3选2原则: 在性能属性里面，吞吐量、延迟、内存占用，我们只能选择其中两个进行调优，不可三者兼得。
       **常用参数**
      - -Xms（初始堆内存），-Xmx（最大堆内存）
      -  -Xmn（新生代空间大小）
      -  -Xss2M（java虚拟机栈大小）
      -  -XX:+UseG1GC（G1回收器），-XX:+UseConcMarkSweepGC（CMS回收器）
      -  XX:PretenureSizeThreshold 空间大于该值的对象之间进入老年代
      -  XX:MaxTenuringThreshold 进入老年代的年龄阈值
      -  -XX:PermSize（永久代空间大小），-XX：MaxPermSize

   参考

   - [如何合理的规划一次jvm性能调优](https://juejin.im/post/6844903506093015053#heading-4)

2. spring ioc容器初始化过程？

   答：

   1. 刷新预处理
    2. 将配置信息解析，注册到BeanFactory
    3. 设置bean的类加载器
    4.如果有第三方想再bean加载注册完成后，初始化前做点什么(例如修改属性的值，修改bean的scope为单例或者多例。)，提供了相应的模板方法，后面还调用了这个方法的实现，并且把这些个实现类注册到对应的容器中
    5.初始化当前的事件广播器
    6.初始化所有的bean
    7.广播applicationcontext初始化完成。